# read DB  - Выборка записей из таблиц
# у нас в БД две таблицы, причем, они связаны между собой через внешний ключ user_id таблицы profiles
# задача сделать выборку по пользователям, в которой бы фигурировали данные из обеих таблиц. Но для начала посмотрим, как вообще осуществляется получение данных
from app import db, Users, Profiles
# то есть, из нашего текущего модуля app импортируем переменную db и классы Users, Profiles.
# Далее, чтобы выбрать все записи, например, из таблицы users, следует выполнить метод all объекта query:
print(Users.query.all())
# [<users 1>] - список состоящий из одной записи, который отображаются в соответствии с определением метода __repr__ в классе Users:
# __repr__()  - метод говорит как возвращать значение данного класса <users {self.id}>

# Сохраним возвращаемый список-[<users 1>, <users 2>, <users 3>, <users 4>] в переменной res
res = Users.query.all()
print(res)

# Получим email из первой записи - обратимся к данным, можем записать следующую конструкцию
print(res[0].email)

# first() - метод возвращает только первую запись
f = Users.query.first()
# обратимся к id первой записи
print(f.id)

# выберем записи по определенному критерию filter_by()
# воспльзуемся методом filter() укажем логическое выражение по которому будут выбираться соответствующие записи
print(Users.query.filter_by(id = 2).all())
print(Users.query.filter(Users.id == 2).all())

# выбрать все записи у которых id > 1
print(Users.query.filter(Users.id > 1).all())

# выбрать лимит число записей
print(Users.query.limit(2).all())

# Выполнять сортировку по определенному полю, например email
print(Users.query.order_by(Users.email).all())
# выполнить сортировку по полю email в обратном порядке
print(Users.query.order_by(Users.email.desc()).all())

# просто получать пользователя по значению первичного ключа, возвратится пользователь с id=2
print(Users.query.get(2))

# Методы можно комбинировать и создавать более сложные запросы

# Выборка из нескольких таблиц
# Например объединим данные из двух наших таблиц и сформируем одну общую выборку.
# Для этого нужно соединить записи таблиц по внешнему ключу user_id, следующим образом:
# db - обращаемся к переменной db которая ссылается на класс SQLalchemy
# session.query() - через сессию обратимя к методу query() и указываем те таблицы, которые мы будем выбирать по данному запросу
# запрос: записи этих таблиц следует объединить между собой использую свойство id из таблицы Users и свойство id из таблицы Profiles
# записи таблицы Profiles будут добавляться к текущим записям таблицы Users
# таблица Users становится главной а таблица Profiles вспомогательной из которой подключаются дополнительно записи, которые соответствуют условию
# all() - мы говорим, что нужно выбрать все записи
res1 = db.session.query(Users, Profiles).join(Profiles, Users.id == Profiles.user_id).all()
print(res1)
# [(<users 1>, <profiles 1>), (<users 2>, <profiles 2>), (<users 3>, <profiles 3>), (<users 4>, <profiles 4>)]
# была взята из таблицы Profiles запись users_id = 1 и запись из таблицы Users users = 1, так были объединены таблицы и сформирована единая выборка

# например мы захотим из первой записи взять email по пользователю, то обращаемся к свойству Users и берем email
print(res1[0].Users.email)
# например из первой записи взять name по пользователю, то обращаемся к свойству Profiles и берем name
print(res1[0].Profiles.name)


# Механизм для связывания таблиц
# Если мы наперед знаем, что необходимо выбирать для каждого пользователя информацию из таблиц users и profiles,
# то в классе Users, как таблицы с «первичными данными», к которой подбираются соответствующие записи из «вторичной таблицы» profiles,
# можно прописать специальную переменную pr:
# pr - через эту переменную будет устанавливаться связь с таблицей Profiles по внешнему ключу user_id.
# backref - параметр  указывает таблицу, к которой присоединять записи из таблицы profiles.
# uselist=False указывает, что одной записи из users должна соответствовать одна запись из profiles,
pr = db.relationship('Profiles', backref='users', uselist=False)
# далее переходим в app.py и прописываем переменную pr в класс Users(db.Model)
# при выборе записи из таблицы pr будет содержать все записи из таблицы Profiles
# далее из таблицы Users будем выбирать все записи-поля
res2 = Users.query.all()
print(res2)
# [<users 1>, <users 2>, <users 3>, <users 4>] - первый элемент этого списка будет содержать data, email, pr
# переменная pr будет содержать все данные из таблицы profiles
# получим, то что возвращает метод __repr__() класса Profiles() и ссылается на все переменные которые в нем определены
print(res[0].pr)
# <profiles 1>
# обратимся к свойству name, чтоб получить имя пользователя, которое ассоциировано с данной записью
print(res[0].pr.name)
# Yurii

# Воспользуемся механизмом (связи между двумя таблицами) через переменную pr для выбора данных
# для отображения на главной странице сайта отобразим список зарегистрированных пользователей